<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle System Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0a0a;
            color: #fff;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #790ECB;
            display: block;
            margin: 20px auto;
            background: #1a1a1a;
        }
        .controls {
            text-align: center;
            margin: 20px;
        }
        button {
            background: #790ECB;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-size: 14px;
            border-radius: 4px;
        }
        button:hover {
            background: #9a3ee0;
        }
        .info {
            text-align: center;
            margin: 10px;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">Particle System Test</h1>
    <canvas id="testCanvas" width="800" height="600"></canvas>
    
    <div class="controls">
        <button onclick="testTrailParticles()">Test Trail Particles</button>
        <button onclick="testTrailMovement()">Test Trail on Movement</button>
        <button onclick="testExplosionParticles()">Test Explosion Particles</button>
        <button onclick="testSparkleParticles()">Test Sparkle Particles</button>
        <button onclick="testConfettiParticles()">Test Confetti Particles</button>
        <button onclick="testParticleLimit()">Test Particle Limit (500)</button>
        <button onclick="clearParticles()">Clear All</button>
    </div>
    
    <div class="info">
        <p>Particle Count: <span id="particleCount">0</span></p>
        <p>Status: <span id="status">Ready</span></p>
    </div>

    <script>
        const canvas = document.getElementById('testCanvas');
        const ctx = canvas.getContext('2d');

        // Effect generator - createTrailParticle
        function createTrailParticle(x, y) {
            return {
                x: x,
                y: y,
                velocityX: 0,
                velocityY: 0,
                life: 0,
                maxLife: 30,
                size: 8,
                color: '#790ECB',
                type: 'trail',
                opacity: 0.6
            };
        }

        // Copy the ParticleSystem from game.js
        const ParticleSystem = {
            particles: [],
            maxParticles: 500,
            
            add(particle) {
                if (Array.isArray(particle)) {
                    particle.forEach(p => this.add(p));
                    return;
                }
                
                if (this.particles.length >= this.maxParticles) {
                    this.particles.shift();
                }
                
                this.particles.push(particle);
            },
            
            update(deltaTime = 1) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    
                    p.life += deltaTime;
                    p.x += p.velocityX;
                    p.y += p.velocityY;
                    
                    if (p.type === 'trail') {
                        p.opacity = Math.max(0, 0.6 * (1 - p.life / p.maxLife));
                    } else if (p.type === 'explosion') {
                        const lifeRatio = p.life / p.maxLife;
                        p.opacity = Math.max(0, 1 - lifeRatio);
                        p.size = Math.max(0, p.size * (1 - lifeRatio * 0.05));
                    } else if (p.type === 'sparkle') {
                        const pulseValue = Math.sin(p.pulsePhase + p.life * 0.1);
                        p.opacity = 0.5 + pulseValue * 0.5;
                        p.scale = 0.8 + pulseValue * 0.4;
                        p.y += p.velocityY;
                    } else if (p.type === 'confetti') {
                        p.velocityY += 0.1;
                        p.rotation += p.rotationSpeed;
                    }
                    
                    if (p.life >= p.maxLife) {
                        this.particles.splice(i, 1);
                        continue;
                    }
                    
                    if (p.x < -50 || p.x > canvas.width + 50 || 
                        p.y < -50 || p.y > canvas.height + 50) {
                        this.particles.splice(i, 1);
                    }
                }
            },
            
            render(ctx) {
                this.particles.forEach(p => {
                    ctx.save();
                    ctx.globalAlpha = p.opacity;
                    
                    if (p.type === 'trail') {
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (p.type === 'explosion') {
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (p.type === 'sparkle') {
                        const scale = p.scale || 1;
                        ctx.fillStyle = p.color;
                        ctx.translate(p.x, p.y);
                        ctx.scale(scale, scale);
                        
                        ctx.beginPath();
                        for (let i = 0; i < 4; i++) {
                            const angle = (i * Math.PI / 2);
                            const outerRadius = p.size * 2;
                            const innerRadius = p.size * 0.5;
                            
                            ctx.lineTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
                            ctx.lineTo(
                                Math.cos(angle + Math.PI / 4) * innerRadius,
                                Math.sin(angle + Math.PI / 4) * innerRadius
                            );
                        }
                        ctx.closePath();
                        ctx.fill();
                    } else if (p.type === 'confetti') {
                        ctx.fillStyle = p.color;
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.rotation);
                        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                    }
                    
                    ctx.restore();
                });
            },
            
            clear() {
                this.particles = [];
            }
        };

        // Test functions
        function testTrailParticles() {
            document.getElementById('status').textContent = 'Testing trail particles...';
            for (let i = 0; i < 20; i++) {
                ParticleSystem.add(createTrailParticle(400 + i * 10, 300));
            }
        }

        // Test trail generation on movement (simulates Kiro logo moving)
        let movingObject = null;
        function testTrailMovement() {
            document.getElementById('status').textContent = 'Testing trail on movement (watch the moving purple circle)...';
            clearParticles();
            
            // Create a moving object that simulates Kiro logo
            movingObject = {
                x: 100,
                y: 300,
                lastX: 100,
                lastY: 300,
                velocityX: 3,
                velocityY: -2,
                width: 60,
                height: 60,
                trailTimer: 0,
                active: true
            };
        }

        function testExplosionParticles() {
            document.getElementById('status').textContent = 'Testing explosion particles...';
            const centerX = 400;
            const centerY = 300;
            const count = 15;
            
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const speed = 2 + Math.random() * 3;
                ParticleSystem.add({
                    x: centerX,
                    y: centerY,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    life: 0,
                    maxLife: 40,
                    size: 4 + Math.random() * 4,
                    color: ['#ff3333', '#ff6600', '#ffaa00'][Math.floor(Math.random() * 3)],
                    type: 'explosion',
                    opacity: 1
                });
            }
        }

        function testSparkleParticles() {
            document.getElementById('status').textContent = 'Testing sparkle particles...';
            const centerX = 400;
            const centerY = 300;
            
            for (let i = 0; i < 10; i++) {
                ParticleSystem.add({
                    x: centerX + (Math.random() - 0.5) * 40,
                    y: centerY + (Math.random() - 0.5) * 40,
                    velocityX: 0,
                    velocityY: -0.5,
                    life: 0,
                    maxLife: 60,
                    size: 3,
                    color: '#ffffff',
                    type: 'sparkle',
                    opacity: 1,
                    pulsePhase: Math.random() * Math.PI * 2,
                    scale: 1
                });
            }
        }

        function testConfettiParticles() {
            document.getElementById('status').textContent = 'Testing confetti particles...';
            const colors = ['#790ECB', '#9a3ee0', '#ffffff', '#ffd700', '#ff69b4'];
            
            for (let i = 0; i < 50; i++) {
                ParticleSystem.add({
                    x: Math.random() * canvas.width,
                    y: -20,
                    velocityX: (Math.random() - 0.5) * 2,
                    velocityY: Math.random() * 2 + 1,
                    life: 0,
                    maxLife: 180,
                    size: 6 + Math.random() * 4,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    type: 'confetti',
                    opacity: 1,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2
                });
            }
        }

        function testParticleLimit() {
            document.getElementById('status').textContent = 'Testing particle limit (adding 600 particles)...';
            for (let i = 0; i < 600; i++) {
                ParticleSystem.add({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    velocityX: (Math.random() - 0.5) * 2,
                    velocityY: (Math.random() - 0.5) * 2,
                    life: 0,
                    maxLife: 100,
                    size: 4,
                    color: '#790ECB',
                    type: 'trail',
                    opacity: 0.6
                });
            }
            setTimeout(() => {
                document.getElementById('status').textContent = 
                    `Particle limit enforced: ${ParticleSystem.particles.length} particles (max 500)`;
            }, 100);
        }

        function clearParticles() {
            ParticleSystem.clear();
            document.getElementById('status').textContent = 'All particles cleared';
        }

        // Animation loop
        function animate() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update moving object if active
            if (movingObject && movingObject.active) {
                // Check if position has changed
                const hasMovedX = movingObject.x !== movingObject.lastX;
                const hasMovedY = movingObject.y !== movingObject.lastY;
                
                if (hasMovedX || hasMovedY) {
                    // Generate trail particles (every 3 frames)
                    movingObject.trailTimer++;
                    if (movingObject.trailTimer >= 3) {
                        const centerX = movingObject.x + movingObject.width / 2;
                        const centerY = movingObject.y + movingObject.height / 2;
                        ParticleSystem.add(createTrailParticle(centerX, centerY));
                        movingObject.trailTimer = 0;
                    }
                    
                    // Update last position
                    movingObject.lastX = movingObject.x;
                    movingObject.lastY = movingObject.y;
                }
                
                // Move the object
                movingObject.x += movingObject.velocityX;
                movingObject.y += movingObject.velocityY;
                
                // Bounce off walls
                if (movingObject.x < 0 || movingObject.x + movingObject.width > canvas.width) {
                    movingObject.velocityX *= -1;
                }
                if (movingObject.y < 0 || movingObject.y + movingObject.height > canvas.height) {
                    movingObject.velocityY *= -1;
                }
                
                // Draw the moving object
                ctx.save();
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = '#790ECB';
                ctx.beginPath();
                ctx.arc(movingObject.x + movingObject.width / 2, 
                       movingObject.y + movingObject.height / 2, 
                       movingObject.width / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            ParticleSystem.update();
            ParticleSystem.render(ctx);
            
            document.getElementById('particleCount').textContent = ParticleSystem.particles.length;
            
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
